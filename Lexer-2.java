
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
/**
 * The Lexer class performs lexical analysis on a given input string.
 * It breaks the string into tokens and categorizes each token as a word,
 * number, punctuation, string literal,
 * character literal, comment, or exception.
 */
public class Lexer {
    private List<Token> tokens;
    private HashMap<String, Token.Type> keywords;
    private HashMap<String, Token.Type> punctuation;
    private int lineNumber;

    /**
     * This method returns the list of tokens generated by the lexer.
     *
     * @return List<Token> - The list of tokens
     */
    public List<Token> getTokens() {
        return tokens;
    }

    /**
     * The constructor initializes an empty list of tokens, a hashmap of keywords and punctuations, and sets
     * the line number to 1.
     */
    public Lexer() {
        this.tokens = new ArrayList<>();
        this.keywords = new HashMap<>();
        this.punctuation = new HashMap<>();
        this.lineNumber = 1;
        // Add keywords and Punctuatios
        addKeyword("if", Token.Type.IF);
        addKeyword("else", Token.Type.ELSE);
        addKeyword("for", Token.Type.FOR);
        addKeyword("while", Token.Type.WHILE);
        addKeyword("do", Token.Type.DO);
        addKeyword("break", Token.Type.BREAK);
        addKeyword("continue", Token.Type.CONTINUE);
        addKeyword("int", Token.Type.INT);
        addKeyword("double", Token.Type.DOUBLE);
        addKeyword("float", Token.Type.FLOAT);
        addKeyword("return", Token.Type.RETURN);
        addKeyword("char", Token.Type.CHAR);
        addKeyword("case", Token.Type.CASE);
        addKeyword("sizeof", Token.Type.SIZEOF);
        addKeyword("long", Token.Type.LONG);
        addKeyword("short", Token.Type.SHORT);
        addKeyword("typedef", Token.Type.TYPEDEF);
        addKeyword("switch", Token.Type.SWITCH);
        addKeyword("unsigned", Token.Type.UNSIGNED);
        addKeyword("void", Token.Type.VOID);
        addKeyword("static", Token.Type.STATIC);
        addKeyword("struct", Token.Type.STRUCT);
        addKeyword("goto", Token.Type.GOTO);
        addKeyword("default", Token.Type.DEFAULT);
        addPunctuation("(", Token.Type.LEFT_PAREN);
        addPunctuation(")", Token.Type.RIGHT_PAREN);
        addPunctuation("{", Token.Type.LEFT_BRACE);
        addPunctuation("}", Token.Type.RIGHT_BRACE);
        addPunctuation("[", Token.Type.LEFT_BRACKET);
        addPunctuation("]", Token.Type.RIGHT_BRACKET);
        addPunctuation(";", Token.Type.SEMICOLON);
        addPunctuation(":", Token.Type.COLON);
    }

    /**
     * This method adds keywords to the hashmap.
     *
     * @param keyword   - The keyword
     * @param Type - The token type of the keyword
     */
    public void addKeyword(String keyword, Token.Type type) {
        keywords.put(keyword, type);
    }

    /**
    * This method adds punctuation to the hashmap.
    *
    * @param punctuation - The punctuation
    * @param Type - The token type of the punctuation
    */
    public void addPunctuation(String punctuation, Token.Type type) {  
        this.punctuation.put(punctuation, type);
    }

    /**
 * This method performs lexical analysis on the input string and populates the tokens list.
 *
 * @param input - The input string
 * @throws SyntaxErrorException
 */
    public void lex(String input) throws SyntaxErrorException {

        // Get the length of the input string
        int length = input.length();

        // Initialize variables to keep track of the start and current positions in the input string
        int start = 0;
        int current = 0;

        // Loop through each character in the input string
        while (current < length) {

            // Get the current character
            char c = input.charAt(current);

            // If the current character is a letter, then it must be a keyword or a variable name
            if (Character.isLetter(c)) {

                // Continue looping through the input string until a non-letter character is found
                while (current < length && Character.isLetter(input.charAt(current))) {
                    current++;
                }

                // Get the word that was found
                String word = input.substring(start, current);

                // Determine if the word is a keyword or a variable name
                Token.Type type = keywords.getOrDefault(word, Token.Type.WORD);

                // Add the token to the list
                tokens.add(new Token(type, word, lineNumber));

                // Update the start position for the next token
                start = current;

            // If the current character is a digit or a period, then it must be a number
            } else if (Character.isDigit(c) || c == '.') {

                // Continue looping through the input string until a non-digit or non-period character is found
                while (current < length && (Character.isDigit(input.charAt(current)) || input.charAt(current) == '.')) {
                    current++;
                }

                // Get the number that was found
                tokens.add(new Token(Token.Type.NUMBER, input.substring(start, current), lineNumber));

                // Update the start position for the next token
                start = current;

            // If the current character is a punctuation character, then it must be a punctuation symbol
            } else if (punctuation.containsKey(String.valueOf(c))) {

                // Get the token type for the punctuation character
                Token.Type type = punctuation.get(String.valueOf(c));

                // Add the token to the list
                tokens.add(new Token(type, String.valueOf(c), lineNumber));

                // Update the start position for the next token
                start = ++current;

            // If the current character is a double-quote, then it must be the start of a string literal
            } else if (c == '"') {

                // Move to the next character
                start++;
                current++;

                // Continue looping through the input string until the closing double-quote is found
                while (current < length && input.charAt(current) != '"') {
                    current++;
                }

                // If the closing double-quote was not found, then the string literal is invalid
                if (current >= length) {
                    throw new SyntaxErrorException("Invalid character literal at line " + lineNumber, lineNumber);
                }

                // Get the string literal that was found
                tokens.add(new Token(Token.Type.STRINGLITERAL, input.substring(start, current), lineNumber));

                // Update the start position for the next token
                start = ++current;
            } else if (c == '\'') {
                start++;
                current++;
                if (current >= length || input.charAt(current) == '\'') {
                    throw new SyntaxErrorException("Invalid character literal at line " + lineNumber, lineNumber);
                }
                char charLiteral = input.charAt(current);
                current++;
                if (current >= length || input.charAt(current) != '\'') {
                    throw new SyntaxErrorException("Invalid character literal at line " + lineNumber, lineNumber);
                }
                tokens.add(new Token(Token.Type.CHARACTERLITERAL, String.valueOf(charLiteral), lineNumber));
                start = ++current;
            } else if (c == '#') {
                while (current < length && input.charAt(current) != '\n') {
                    current++;
                }
                
                start = current;
            } else if (c == '\n') {
                lineNumber++;
                // Whitespace found, skip to next non-whitespace character
                start = ++current;
            } else if (Character.isWhitespace(c)) {
                if (c == '\n') {
                    lineNumber++;
                }
                start = ++current;
            }else if (c == '/' && current + 1 < length && input.charAt(current + 1) == '/') {
                while (current < length && input.charAt(current) != '\n') {
                    current++;
                }
                start = current;
            // If the current character is the start of a multi-line comment
            } else if (c == '/' && current + 1 < length && input.charAt(current + 1) == '*') {
                current += 2;
                while (current < length && (input.charAt(current) != '*' || (current + 1 < length && input.charAt(current + 1) != '/'))) {
                    if (input.charAt(current) == '\n') {
                        lineNumber++;
                    }
                    current++;
                }

                // If the closing "*/" was not found, then the multi-line comment is invalid
                if (current >= length || input.charAt(current + 1) != '/') {
                    throw new SyntaxErrorException("Unclosed multi-line comment at line " + lineNumber, lineNumber);
                }

                current += 2;
                start = current;
            // If none of the above conditions match, the character is invalid
            }else {
                throw new SyntaxErrorException("Invalid character '" + c + "' at line " + lineNumber, lineNumber);
            }
        }
    }
}